name: CI / CD (no third-party actions)

on:
  push:
    # Run tests on all branch pushes; deployment jobs only trigger on main
    branches: [ '**' ]
  pull_request:
    # Run tests on all PRs
    branches: [ '**' ]
  workflow_dispatch:

defaults:
  run:
    shell: bash

# Environment variables for deployment
env:
  REGISTRY: sautairegistry
  RESOURCE_GROUP: sautAI
  # Backend apps
  DJANGO_APP: sautai-django-westus2
  CELERY_WORKER_APP: sautai-celery-worker-westus2
  # Frontend (Azure Static Web App)
  SWA_NAME: sautai-frontend
  VITE_API_BASE: https://sautai-django-westus2.redcliff-686826f3.westus2.azurecontainerapps.io

jobs:
  # ============================================================================
  # Frontend: API path audits and tests
  # ============================================================================
  frontend-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install pnpm
        run: npm install -g pnpm

      - name: Install frontend dependencies
        working-directory: frontend
        run: pnpm install --frozen-lockfile

      - name: Run API path audit
        working-directory: frontend
        run: node scripts/audit-api-paths.mjs

      - name: Run React hooks audit
        working-directory: frontend
        run: node scripts/audit-react-hooks.mjs

      - name: Run frontend tests
        working-directory: frontend
        run: node --test tests/*.test.mjs

  # ============================================================================
  # Backend: Django tests
  # ============================================================================
  backend-test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: ramsrib/pgvector
        env:
          POSTGRES_DB: test_db
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          if [ -f requirements-dev.txt ]; then pip install -r requirements-dev.txt; fi
          # Explicitly ensure pytest is present
          pip install pytest

      # 1) Write the dev .env into runner env
      - name: Export dev .env
        run: |
          echo "$DEV_DOTENV" > .env

          # Promote every KEY=value pair to future steps via $GITHUB_ENV
          while IFS= read -r line || [ -n "$line" ]; do
            [[ "$line" =~ ^[[:space:]]*$ ]] && continue        # skip blanks
            [[ "$line" =~ ^[[:space:]]*# ]] && continue        # skip comments
            [[ "$line" != *"="* ]] && { echo "Malformed .env line: $line" >&2; exit 1; }
            echo "$line" >> "$GITHUB_ENV"
          done
        env:
          DEV_DOTENV: ${{ secrets.DEV_DOTENV }}

      # 2) Run test suite with explicitly set DJANGO_SETTINGS_MODULE
      - name: Run checks and tests
        env:
          TEST_MODE: "True"
          # Keep DEBUG=True so settings.py uses local memory cache (no Redis needed)
          # and TEST_DB_* variables for database connection
          DEBUG: "True"
          # Set TEST_DB_* variables for when DEBUG=True
          TEST_DB_NAME: test_db
          TEST_DB_USER: test_user
          TEST_DB_PASSWORD: test_password
          TEST_DB_HOST: localhost
          TEST_DB_PORT: "5432"
        run: |
          export DJANGO_SETTINGS_MODULE=hood_united.settings
          # Ensure SECRET_KEY is never empty in CI
          export SECRET_KEY=${SECRET_KEY:-dummy-test-secret}
          # Mock OpenAI API key for tests
          export OPENAI_API_KEY=dummy-key-for-testing
          export ALLOWED_HOSTS="*"
          # Django checks before tests
          python manage.py makemigrations --check --dry-run
          python manage.py migrate --noinput
          python manage.py check
          python -m pytest

  # ============================================================================
  # Deploy Backend (only on push to main, after tests pass)
  # ============================================================================
  deploy-backend:
    runs-on: ubuntu-latest
    needs: [frontend-test, backend-test]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to ACR
        run: |
          az acr login --name ${{ env.REGISTRY }}

      - name: Security check - DEBUG must be False
        run: |
          debug_line=$(grep "^DEBUG = " hood_united/settings.py | head -1)
          echo "Found DEBUG setting: $debug_line"
          if echo "$debug_line" | grep -q "str_to_bool.*'False'"; then
            echo "✅ DEBUG uses environment variable with False default"
          elif echo "$debug_line" | grep -q "^DEBUG = False$"; then
            echo "✅ DEBUG is correctly set to False"
          else
            echo "❌ ERROR: DEBUG must be set to False for production"
            exit 1
          fi

      - name: Build and push Django image
        run: |
          docker build --platform linux/amd64 \
            -f Dockerfile.django \
            -t ${{ env.REGISTRY }}.azurecr.io/django:${{ github.sha }} \
            -t ${{ env.REGISTRY }}.azurecr.io/django:latest \
            .
          docker push ${{ env.REGISTRY }}.azurecr.io/django:${{ github.sha }}
          docker push ${{ env.REGISTRY }}.azurecr.io/django:latest

      - name: Build and push Celery worker image
        run: |
          docker build --platform linux/amd64 \
            -f Dockerfile.celery \
            -t ${{ env.REGISTRY }}.azurecr.io/celery-worker:${{ github.sha }} \
            -t ${{ env.REGISTRY }}.azurecr.io/celery-worker:latest \
            .
          docker push ${{ env.REGISTRY }}.azurecr.io/celery-worker:${{ github.sha }}
          docker push ${{ env.REGISTRY }}.azurecr.io/celery-worker:latest

      - name: Build and push Celery beat image
        run: |
          docker build --platform linux/amd64 \
            -f Dockerfile.celery-beat \
            -t ${{ env.REGISTRY }}.azurecr.io/celery-beat:${{ github.sha }} \
            -t ${{ env.REGISTRY }}.azurecr.io/celery-beat:latest \
            .
          docker push ${{ env.REGISTRY }}.azurecr.io/celery-beat:${{ github.sha }}
          docker push ${{ env.REGISTRY }}.azurecr.io/celery-beat:latest

      - name: Deploy Django to Container Apps
        run: |
          az containerapp update \
            --name ${{ env.DJANGO_APP }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --image ${{ env.REGISTRY }}.azurecr.io/django:${{ github.sha }}

      - name: Deploy Celery Worker to Container Apps
        run: |
          az containerapp update \
            --name ${{ env.CELERY_WORKER_APP }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --image ${{ env.REGISTRY }}.azurecr.io/celery-worker:${{ github.sha }}

      - name: Deploy Celery Beat to Container Apps
        run: |
          az containerapp update \
            --name ${{ env.CELERY_BEAT_APP }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --image ${{ env.REGISTRY }}.azurecr.io/celery-beat:${{ github.sha }}

  # ============================================================================
  # Deploy Frontend to Azure Static Web App (only on push to main, after tests pass)
  # ============================================================================
  deploy-frontend:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [frontend-test, backend-test]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install pnpm
        run: npm install -g pnpm

      - name: Install frontend dependencies
        working-directory: frontend
        run: pnpm install --frozen-lockfile

      - name: Build frontend
        working-directory: frontend
        env:
          VITE_API_BASE: ${{ env.VITE_API_BASE }}
        run: pnpm run build

      - name: Verify SWA deployment token is present
        working-directory: frontend
        env:
          SWA_CLI_DEPLOYMENT_TOKEN: ${{ secrets.SWA_DEPLOYMENT_TOKEN }}
        run: |
          if [ -z "$SWA_CLI_DEPLOYMENT_TOKEN" ]; then
            echo "❌ Missing SWA_DEPLOYMENT_TOKEN secret. Add it in GitHub → Settings → Secrets → Actions."
            exit 1
          fi
          echo "✅ SWA_DEPLOYMENT_TOKEN present (length: ${#SWA_CLI_DEPLOYMENT_TOKEN})"

      - name: Verify staticwebapp.config.json is in dist
        working-directory: frontend
        run: |
          if [ ! -f "dist/staticwebapp.config.json" ]; then
            echo "❌ staticwebapp.config.json not found in dist/"
            echo "Copying from public/ to dist/"
            cp public/staticwebapp.config.json dist/
          fi
          echo "✅ staticwebapp.config.json present in dist/"
          cat dist/staticwebapp.config.json

      - name: Deploy to Azure Static Web App
        working-directory: frontend
        env:
          SWA_CLI_DEPLOYMENT_TOKEN: ${{ secrets.SWA_DEPLOYMENT_TOKEN }}
        run: |
          npx --yes @azure/static-web-apps-cli@2.0.7 deploy dist \
            --deployment-token "$SWA_CLI_DEPLOYMENT_TOKEN" \
            --env production \
            --verbose
