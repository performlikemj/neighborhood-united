"""
Notifications API endpoints for Sous Chef proactive engine.

Provides endpoints for listing, reading, and dismissing notifications
generated by the proactive check task.
"""

import logging

from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

from chefs.models import Chef, ChefNotification

logger = logging.getLogger(__name__)


def _get_chef_or_403(request):
    """Get the Chef instance for the authenticated user."""
    try:
        chef = Chef.objects.select_related('user').get(user=request.user)
        return chef, None
    except Chef.DoesNotExist:
        return None, Response(
            {"error": "Not a chef. Only chefs can access notifications."},
            status=403
        )


def _serialize_notification(notification: ChefNotification) -> dict:
    """Serialize a notification for API response."""
    # Get client/lead name if available
    client_name = None
    client_type = None
    client_id = None

    if notification.related_client:
        client = notification.related_client
        client_name = client.get_full_name() or client.username
        client_type = 'customer'
        client_id = client.id
    elif notification.related_lead:
        lead = notification.related_lead
        client_name = f"{lead.first_name} {lead.last_name}".strip()
        client_type = 'lead'
        client_id = lead.id

    return {
        "id": notification.id,
        "type": notification.notification_type,
        "status": notification.status,
        "title": notification.title,
        "message": notification.message,
        "client_name": client_name,
        "client_type": client_type,
        "client_id": client_id,
        "action_context": notification.action_context,
        "created_at": notification.created_at.isoformat(),
        "sent_at": notification.sent_at.isoformat() if notification.sent_at else None,
        "read_at": notification.read_at.isoformat() if notification.read_at else None,
    }


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def notifications_list(request):
    """
    GET /chefs/api/me/notifications/

    List notifications for the chef.

    Query parameters:
    - status: Filter by status (pending, sent, read, dismissed)
    - type: Filter by notification type
    - limit: Max results (default 50, max 100)
    - offset: Pagination offset
    - unread_only: If "true", only show unread (pending/sent) notifications
    """
    chef, error_response = _get_chef_or_403(request)
    if error_response:
        return error_response

    # Base queryset
    qs = ChefNotification.objects.filter(chef=chef)

    # Filter by status
    status = request.query_params.get('status')
    if status:
        valid_statuses = [c[0] for c in ChefNotification.STATUS_CHOICES]
        if status in valid_statuses:
            qs = qs.filter(status=status)

    # Filter by type
    notif_type = request.query_params.get('type')
    if notif_type:
        valid_types = [c[0] for c in ChefNotification.NOTIFICATION_TYPES]
        if notif_type in valid_types:
            qs = qs.filter(notification_type=notif_type)

    # Unread only filter
    unread_only = request.query_params.get('unread_only', '').lower() == 'true'
    if unread_only:
        qs = qs.filter(status__in=[
            ChefNotification.STATUS_PENDING,
            ChefNotification.STATUS_SENT
        ])

    # Pagination
    try:
        limit = min(int(request.query_params.get('limit', 50)), 100)
    except ValueError:
        limit = 50

    try:
        offset = int(request.query_params.get('offset', 0))
    except ValueError:
        offset = 0

    # Get total count before slicing
    total = qs.count()

    # Order and slice
    notifications = qs.order_by('-created_at')[offset:offset + limit]

    return Response({
        "status": "success",
        "total": total,
        "limit": limit,
        "offset": offset,
        "notifications": [_serialize_notification(n) for n in notifications],
    })


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def notifications_unread_count(request):
    """
    GET /chefs/api/me/notifications/unread-count/

    Get count of unread notifications.
    Useful for badge display.
    """
    chef, error_response = _get_chef_or_403(request)
    if error_response:
        return error_response

    count = ChefNotification.get_unread_count(chef)

    return Response({
        "status": "success",
        "unread_count": count,
    })


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def notification_detail(request, notification_id):
    """
    GET /chefs/api/me/notifications/<id>/

    Get details of a specific notification.
    """
    chef, error_response = _get_chef_or_403(request)
    if error_response:
        return error_response

    try:
        notification = ChefNotification.objects.get(id=notification_id, chef=chef)
    except ChefNotification.DoesNotExist:
        return Response(
            {"error": "Notification not found"},
            status=404
        )

    return Response({
        "status": "success",
        "notification": _serialize_notification(notification),
    })


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def notification_mark_read(request, notification_id):
    """
    POST /chefs/api/me/notifications/<id>/read/

    Mark a notification as read.
    """
    chef, error_response = _get_chef_or_403(request)
    if error_response:
        return error_response

    try:
        notification = ChefNotification.objects.get(id=notification_id, chef=chef)
    except ChefNotification.DoesNotExist:
        return Response(
            {"error": "Notification not found"},
            status=404
        )

    notification.mark_read()

    return Response({
        "status": "success",
        "notification": _serialize_notification(notification),
    })


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def notification_dismiss(request, notification_id):
    """
    POST /chefs/api/me/notifications/<id>/dismiss/

    Dismiss a notification (won't show in unread).
    """
    chef, error_response = _get_chef_or_403(request)
    if error_response:
        return error_response

    try:
        notification = ChefNotification.objects.get(id=notification_id, chef=chef)
    except ChefNotification.DoesNotExist:
        return Response(
            {"error": "Notification not found"},
            status=404
        )

    notification.mark_dismissed()

    return Response({
        "status": "success",
        "notification": _serialize_notification(notification),
    })


@api_view(['DELETE'])
@permission_classes([IsAuthenticated])
def notification_delete(request, notification_id):
    """
    DELETE /chefs/api/me/notifications/<id>/

    Permanently delete a notification.
    """
    chef, error_response = _get_chef_or_403(request)
    if error_response:
        return error_response

    try:
        notification = ChefNotification.objects.get(id=notification_id, chef=chef)
    except ChefNotification.DoesNotExist:
        return Response(
            {"error": "Notification not found"},
            status=404
        )

    notification_id = notification.id
    notification.delete()

    logger.info(f"Chef {chef.id} deleted notification {notification_id}")

    return Response({
        "status": "success",
        "deleted_id": notification_id,
    })


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def notifications_mark_all_read(request):
    """
    POST /chefs/api/me/notifications/mark-all-read/

    Mark all unread notifications as read.
    """
    chef, error_response = _get_chef_or_403(request)
    if error_response:
        return error_response

    from django.utils import timezone

    updated = ChefNotification.objects.filter(
        chef=chef,
        status__in=[ChefNotification.STATUS_PENDING, ChefNotification.STATUS_SENT]
    ).update(
        status=ChefNotification.STATUS_READ,
        read_at=timezone.now()
    )

    logger.info(f"Chef {chef.id} marked {updated} notifications as read")

    return Response({
        "status": "success",
        "marked_count": updated,
    })


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def notifications_dismiss_all(request):
    """
    POST /chefs/api/me/notifications/dismiss-all/

    Dismiss all notifications.
    """
    chef, error_response = _get_chef_or_403(request)
    if error_response:
        return error_response

    from django.utils import timezone

    updated = ChefNotification.objects.filter(
        chef=chef,
        status__in=[
            ChefNotification.STATUS_PENDING,
            ChefNotification.STATUS_SENT,
            ChefNotification.STATUS_READ
        ]
    ).update(
        status=ChefNotification.STATUS_DISMISSED,
        dismissed_at=timezone.now()
    )

    logger.info(f"Chef {chef.id} dismissed {updated} notifications")

    return Response({
        "status": "success",
        "dismissed_count": updated,
    })
