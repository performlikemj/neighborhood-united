# meals/scaffold_engine.py
"""
Meal Scaffolding Engine

Generates complete meal structures (meals, dishes, ingredients) using AI,
allowing chefs to quickly create related artifacts with a single action.
"""

import json
import logging
import uuid
from typing import Dict, Any, List, Optional
from dataclasses import dataclass, field, asdict
from decimal import Decimal

from django.db import transaction
from django.utils import timezone

from chefs.models import Chef
from meals.models import Meal, Dish, Ingredient

logger = logging.getLogger(__name__)


@dataclass
class ScaffoldItem:
    """A single item in the scaffold tree."""
    id: str
    type: str  # 'meal', 'dish', 'ingredient'
    data: Dict[str, Any]
    children: List['ScaffoldItem'] = field(default_factory=list)
    status: str = 'suggested'  # 'suggested', 'edited', 'removed', 'exists'
    existing_id: Optional[int] = None  # If this matches an existing item
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            'id': self.id,
            'type': self.type,
            'data': self.data,
            'children': [child.to_dict() for child in self.children],
            'status': self.status,
            'existingId': self.existing_id
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ScaffoldItem':
        """Create from dictionary (for deserializing from frontend)."""
        children = [cls.from_dict(c) for c in data.get('children', [])]
        return cls(
            id=data['id'],
            type=data['type'],
            data=data['data'],
            children=children,
            status=data.get('status', 'suggested'),
            existing_id=data.get('existingId')
        )


class ScaffoldEngine:
    """
    Engine for generating and executing meal scaffolds.
    
    A scaffold is a tree structure representing a meal with its dishes
    and optionally ingredients, all generated by AI based on a hint.
    """
    
    def __init__(self, chef: Chef):
        self.chef = chef
        self._chef_context = None
    
    def generate_scaffold(
        self,
        hint: str,
        include_dishes: bool = True,
        include_ingredients: bool = False,
        meal_type: str = 'Dinner'
    ) -> ScaffoldItem:
        """
        Generate a scaffold tree based on the hint.
        
        Args:
            hint: Name or description hint for the meal
            include_dishes: Whether to generate dish suggestions
            include_ingredients: Whether to generate ingredient suggestions
            meal_type: Type of meal (Breakfast, Lunch, Dinner)
            
        Returns:
            ScaffoldItem tree with meal at root
        """
        # Get chef context for better suggestions
        chef_context = self._get_chef_context()
        
        # Generate using AI
        scaffold_data = self._call_ai_for_scaffold(
            hint=hint,
            include_dishes=include_dishes,
            include_ingredients=include_ingredients,
            meal_type=meal_type,
            chef_context=chef_context
        )
        
        # Convert to ScaffoldItem tree
        scaffold = self._build_scaffold_tree(scaffold_data)
        
        # Check for existing items (duplicates)
        self._mark_existing_items(scaffold)
        
        return scaffold
    
    def validate_scaffold(self, scaffold: ScaffoldItem) -> Dict[str, Any]:
        """
        Validate a scaffold before execution.
        
        Returns:
            Dict with 'valid' bool and 'errors' list
        """
        errors = []
        warnings = []
        
        # Check meal data
        if scaffold.type != 'meal':
            errors.append("Root item must be a meal")
        
        meal_data = scaffold.data
        if not meal_data.get('name'):
            errors.append("Meal name is required")
        
        # Check dishes
        active_dishes = [c for c in scaffold.children if c.status != 'removed']
        if not active_dishes:
            warnings.append("No dishes selected - meal will be created without dishes")
        
        # Check for duplicate names
        dish_names = set()
        for dish in active_dishes:
            name = dish.data.get('name', '').lower()
            if name in dish_names:
                errors.append(f"Duplicate dish name: {dish.data.get('name')}")
            dish_names.add(name)
        
        return {
            'valid': len(errors) == 0,
            'errors': errors,
            'warnings': warnings
        }
    
    @transaction.atomic
    def execute_scaffold(self, scaffold: ScaffoldItem) -> Dict[str, Any]:
        """
        Execute a scaffold, creating all items in the database.
        
        Args:
            scaffold: The scaffold tree to execute
            
        Returns:
            Dict with created item IDs and summary
        """
        # Validate first
        validation = self.validate_scaffold(scaffold)
        if not validation['valid']:
            return {
                'status': 'error',
                'message': 'Validation failed',
                'errors': validation['errors']
            }
        
        created = {
            'meal': None,
            'dishes': [],
            'ingredients': []
        }
        
        try:
            # First, create or find ingredients
            ingredient_map = {}  # name -> Ingredient instance
            for dish_item in scaffold.children:
                if dish_item.status == 'removed':
                    continue
                for ing_item in dish_item.children:
                    if ing_item.status == 'removed':
                        continue
                    if ing_item.type == 'ingredient':
                        ingredient = self._create_or_get_ingredient(ing_item)
                        ingredient_map[ing_item.id] = ingredient
                        if ing_item.status != 'exists':
                            created['ingredients'].append({
                                'id': ingredient.id,
                                'name': ingredient.name
                            })
            
            # Create dishes
            dish_map = {}  # scaffold_id -> Dish instance
            for dish_item in scaffold.children:
                if dish_item.status == 'removed':
                    continue
                if dish_item.type == 'dish':
                    dish = self._create_or_get_dish(dish_item, ingredient_map)
                    dish_map[dish_item.id] = dish
                    if dish_item.status != 'exists':
                        created['dishes'].append({
                            'id': dish.id,
                            'name': dish.name
                        })
                    else:
                        # Include existing dishes too so they can be added to meal form
                        created['dishes'].append({
                            'id': dish.id,
                            'name': dish.name,
                            'existed': True
                        })
            
            # DON'T create the meal - the meal form will handle that
            # Just return the suggested meal data and dish IDs for the form to use
            created['meal'] = {
                'suggested_name': scaffold.data.get('name'),
                'suggested_description': scaffold.data.get('description'),
                'suggested_price': scaffold.data.get('price'),
                'suggested_meal_type': scaffold.data.get('meal_type'),
                'dish_ids': [dish.id for dish in dish_map.values()]
            }
            
            return {
                'status': 'success',
                'created': created,
                'summary': {
                    'meal': 0,  # Meal not created, just dishes
                    'dishes': len([d for d in created['dishes'] if not d.get('existed')]),
                    'ingredients': len(created['ingredients'])
                },
                'form_prefill': {
                    'name': scaffold.data.get('name'),
                    'description': scaffold.data.get('description'),
                    'price': scaffold.data.get('price'),
                    'meal_type': scaffold.data.get('meal_type'),
                    'dish_ids': [dish.id for dish in dish_map.values()]
                }
            }
            
        except Exception as e:
            logger.error(f"Scaffold execution failed: {e}")
            raise
    
    def _call_ai_for_scaffold(
        self,
        hint: str,
        include_dishes: bool,
        include_ingredients: bool,
        meal_type: str,
        chef_context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Call AI to generate scaffold structure."""
        from groq import Groq
        from django.conf import settings
        
        # Build the prompt
        prompt = self._build_scaffold_prompt(
            hint=hint,
            include_dishes=include_dishes,
            include_ingredients=include_ingredients,
            meal_type=meal_type,
            chef_context=chef_context
        )
        
        try:
            client = Groq(api_key=settings.GROQ_API_KEY)
            
            response = client.chat.completions.create(
                model="llama-3.1-8b-instant",
                messages=[
                    {
                        "role": "system",
                        "content": """You are a culinary assistant helping a chef create meal structures. 
Generate realistic, appetizing meal components based on the chef's style and the given hint.
Return valid JSON only, following the exact structure requested."""
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                temperature=0.7,
                max_tokens=1500,
                response_format={"type": "json_object"}
            )
            
            result_text = response.choices[0].message.content
            result = json.loads(result_text)
            
            return result
            
        except Exception as e:
            logger.error(f"AI scaffold generation failed: {e}")
            # Return a basic fallback structure
            return self._generate_fallback_scaffold(hint, meal_type)
    
    def _build_scaffold_prompt(
        self,
        hint: str,
        include_dishes: bool,
        include_ingredients: bool,
        meal_type: str,
        chef_context: Dict[str, Any]
    ) -> str:
        """Build the AI prompt for scaffold generation."""
        
        existing_dishes = chef_context.get('existing_dishes', [])
        
        # Build the JSON structure based on what's requested
        if include_ingredients:
            dish_structure = '''{{
      "name": "Dish name",
      "featured": false,
      "ingredients": ["ingredient1", "ingredient2", "ingredient3"]
    }}'''
            ingredient_guidelines = """
- Each dish should have 3-6 key ingredients
- Use proper culinary terminology for ingredients (e.g., "chicken thighs" not "chicken", "extra virgin olive oil" not "oil")
- Include only the main ingredients a chef would need to know, not common staples like salt/pepper
- Ingredient names should be specific enough to shop for"""
        else:
            dish_structure = '''{{
      "name": "Dish name",
      "featured": false,
      "ingredients": []
    }}'''
            ingredient_guidelines = ""
        
        prompt = f"""Create a meal structure for: "{hint}"

Chef context:
- Chef name: {chef_context.get('name', 'Chef')}
- Existing dishes: {', '.join(existing_dishes[:10]) if existing_dishes else 'None yet'}

Requirements:
- Meal type: {meal_type}
- Generate dishes: {include_dishes}
- Generate ingredients: {include_ingredients}

Return JSON in this exact format:
{{
  "meal": {{
    "name": "Meal name based on hint",
    "description": "Appetizing description (2-3 sentences)",
    "price": <suggested price as number>,
    "meal_type": "{meal_type}",
    "cuisine_hint": "detected cuisine style if any"
  }},
  "dishes": [
    {dish_structure}
  ]
}}

Guidelines:
- Generate 2-4 dishes that complement each other well
- Dish names should be descriptive and appetizing (e.g., "Herb-Crusted Salmon" not just "Salmon")
- Price should be reasonable ($15-60 range typically)
- Description should be enticing and mention key dishes{ingredient_guidelines}
"""
        
        if not include_dishes:
            prompt += "\nIMPORTANT: Set dishes to an empty array since include_dishes is false."
        
        return prompt
    
    def _generate_fallback_scaffold(self, hint: str, meal_type: str) -> Dict[str, Any]:
        """Generate a basic scaffold when AI fails."""
        return {
            "meal": {
                "name": hint or f"New {meal_type}",
                "description": f"A delicious {meal_type.lower()} featuring our signature dishes.",
                "price": 25,
                "meal_type": meal_type
            },
            "dishes": []
        }
    
    def _build_scaffold_tree(self, data: Dict[str, Any]) -> ScaffoldItem:
        """Convert AI response to ScaffoldItem tree."""
        meal_data = data.get('meal', {})
        dishes_data = data.get('dishes', [])
        
        # Build dish children
        dish_items = []
        for dish in dishes_data:
            # Build ingredient children
            ingredient_items = []
            for ing_name in dish.get('ingredients', []):
                ingredient_items.append(ScaffoldItem(
                    id=str(uuid.uuid4()),
                    type='ingredient',
                    data={'name': ing_name},
                    children=[],
                    status='suggested'
                ))
            
            dish_items.append(ScaffoldItem(
                id=str(uuid.uuid4()),
                type='dish',
                data={
                    'name': dish.get('name', 'Unnamed Dish'),
                    'featured': dish.get('featured', False)
                },
                children=ingredient_items,
                status='suggested'
            ))
        
        # Build meal root
        return ScaffoldItem(
            id=str(uuid.uuid4()),
            type='meal',
            data={
                'name': meal_data.get('name', 'New Meal'),
                'description': meal_data.get('description', ''),
                'price': meal_data.get('price', 25),
                'meal_type': meal_data.get('meal_type', 'Dinner'),
                'cuisine_hint': meal_data.get('cuisine_hint', '')
            },
            children=dish_items,
            status='suggested'
        )
    
    def _mark_existing_items(self, scaffold: ScaffoldItem):
        """Mark items that already exist in the database."""
        # Check for existing meal
        meal_name = scaffold.data.get('name', '').lower()
        existing_meal = Meal.objects.filter(
            chef=self.chef,
            name__iexact=meal_name
        ).first()
        if existing_meal:
            scaffold.status = 'exists'
            scaffold.existing_id = existing_meal.id
        
        # Check for existing dishes
        for dish_item in scaffold.children:
            if dish_item.type == 'dish':
                dish_name = dish_item.data.get('name', '').lower()
                existing_dish = Dish.objects.filter(
                    chef=self.chef,
                    name__iexact=dish_name
                ).first()
                if existing_dish:
                    dish_item.status = 'exists'
                    dish_item.existing_id = existing_dish.id
                
                # Check ingredients
                for ing_item in dish_item.children:
                    if ing_item.type == 'ingredient':
                        ing_name = ing_item.data.get('name', '').lower()
                        existing_ing = Ingredient.objects.filter(
                            chef=self.chef,
                            name__iexact=ing_name
                        ).first()
                        if existing_ing:
                            ing_item.status = 'exists'
                            ing_item.existing_id = existing_ing.id
    
    def _create_or_get_ingredient(self, item: ScaffoldItem) -> Ingredient:
        """Create an ingredient or return existing one."""
        from django.db import IntegrityError, transaction
        
        ing_name = item.data.get('name', 'Unnamed Ingredient')
        
        # If we have an existing_id, use it
        if item.existing_id:
            try:
                return Ingredient.objects.get(id=item.existing_id)
            except Ingredient.DoesNotExist:
                pass  # Fall through
        
        # Always try to get existing first
        existing = Ingredient.objects.filter(
            chef=self.chef,
            name__iexact=ing_name
        ).first()
        if existing:
            item.existing_id = existing.id
            return existing
        
        # Try to create with savepoint
        try:
            with transaction.atomic():
                ingredient = Ingredient.objects.create(
                    chef=self.chef,
                    name=ing_name,
                    is_custom=True
                )
                item.existing_id = ingredient.id
                return ingredient
        except IntegrityError:
            # Retry get
            existing = Ingredient.objects.filter(
                chef=self.chef,
                name__iexact=ing_name
            ).first()
            if existing:
                item.existing_id = existing.id
                return existing
            # Fallback with modified name
            try:
                with transaction.atomic():
                    ingredient = Ingredient.objects.create(
                        chef=self.chef,
                        name=f"{ing_name} (new)",
                        is_custom=True
                    )
                    item.existing_id = ingredient.id
                    return ingredient
            except IntegrityError:
                # Last resort
                any_ing = Ingredient.objects.filter(chef=self.chef).first()
                if any_ing:
                    return any_ing
                raise
    
    def _create_or_get_dish(
        self,
        item: ScaffoldItem,
        ingredient_map: Dict[str, Ingredient]
    ) -> Dish:
        """Create a dish or return existing one."""
        from django.db import IntegrityError
        
        dish_name = item.data.get('name', 'Unnamed Dish')
        
        # If we have an existing_id, use it
        if item.existing_id:
            try:
                return Dish.objects.get(id=item.existing_id)
            except Dish.DoesNotExist:
                pass  # Fall through to create/get by name
        
        # Always try to get existing dish first (case-insensitive)
        existing = Dish.objects.filter(
            chef=self.chef,
            name__iexact=dish_name
        ).first()
        if existing:
            item.existing_id = existing.id
            return existing
        
        # Try to create with savepoint to handle IntegrityError
        try:
            from django.db import transaction
            with transaction.atomic():  # Creates savepoint when nested
                dish = Dish.objects.create(
                    chef=self.chef,
                    name=dish_name,
                    featured=item.data.get('featured', False)
                )
                
                # Add ingredients
                for ing_item in item.children:
                    if ing_item.status != 'removed' and ing_item.id in ingredient_map:
                        dish.ingredients.add(ingredient_map[ing_item.id])
                
                item.existing_id = dish.id
                return dish
            
        except IntegrityError:
            # Sequence collision - try to get again, it may have been created
            existing = Dish.objects.filter(
                chef=self.chef,
                name__iexact=dish_name
            ).first()
            if existing:
                item.existing_id = existing.id
                return existing
            
            # Still not found - try with modified name
            try:
                from django.db import transaction
                with transaction.atomic():
                    dish = Dish.objects.create(
                        chef=self.chef,
                        name=f"{dish_name} (new)",
                        featured=item.data.get('featured', False)
                    )
                    item.existing_id = dish.id
                    return dish
            except IntegrityError:
                # Last resort - get any matching dish
                any_dish = Dish.objects.filter(chef=self.chef).first()
                if any_dish:
                    return any_dish
                raise  # Re-raise if nothing works
    
    def _create_meal(self, item: ScaffoldItem, dishes: List[Dish]) -> Meal:
        """Create a meal from scaffold item."""
        from django.db import IntegrityError, transaction
        
        meal_name = item.data.get('name', 'New Meal')
        
        # If we have an existing_id, use it
        if item.existing_id:
            try:
                meal = Meal.objects.get(id=item.existing_id)
                # Add any new dishes to existing meal
                for dish in dishes:
                    meal.dishes.add(dish)
                return meal
            except Meal.DoesNotExist:
                pass  # Fall through to create
        
        # Always try to get existing first
        existing = Meal.objects.filter(
            chef=self.chef,
            name__iexact=meal_name
        ).first()
        if existing:
            item.existing_id = existing.id
            for dish in dishes:
                existing.dishes.add(dish)
            return existing
        
        # Try to create with savepoint
        try:
            with transaction.atomic():
                meal = Meal.objects.create(
                    chef=self.chef,
                    name=meal_name,
                    description=item.data.get('description', ''),
                    price=Decimal(str(item.data.get('price', 25))),
                    meal_type=item.data.get('meal_type', 'Dinner')
                )
                for dish in dishes:
                    meal.dishes.add(dish)
                item.existing_id = meal.id
                return meal
        except IntegrityError:
            # Retry get
            existing = Meal.objects.filter(
                chef=self.chef,
                name__iexact=meal_name
            ).first()
            if existing:
                item.existing_id = existing.id
                for dish in dishes:
                    existing.dishes.add(dish)
                return existing
            # Fallback with modified name
            try:
                with transaction.atomic():
                    meal = Meal.objects.create(
                        chef=self.chef,
                        name=f"{meal_name} (new)",
                        description=item.data.get('description', ''),
                        price=Decimal(str(item.data.get('price', 25))),
                        meal_type=item.data.get('meal_type', 'Dinner')
                    )
                    for dish in dishes:
                        meal.dishes.add(dish)
                    item.existing_id = meal.id
                    return meal
            except IntegrityError:
                # Last resort - get any meal and add dishes to it
                any_meal = Meal.objects.filter(chef=self.chef).first()
                if any_meal:
                    for dish in dishes:
                        any_meal.dishes.add(dish)
                    return any_meal
                raise
    
    def _get_chef_context(self) -> Dict[str, Any]:
        """Get chef context for AI prompts."""
        if self._chef_context is not None:
            return self._chef_context
        
        existing_dishes = list(
            Dish.objects.filter(chef=self.chef)
            .order_by('-id')[:20]
            .values_list('name', flat=True)
        )
        
        existing_meals = list(
            Meal.objects.filter(chef=self.chef)
            .order_by('-created_date')[:10]
            .values_list('name', flat=True)
        )
        
        self._chef_context = {
            'name': self.chef.user.first_name or self.chef.user.username,
            'existing_dishes': existing_dishes,
            'existing_meals': existing_meals,
        }
        
        return self._chef_context
